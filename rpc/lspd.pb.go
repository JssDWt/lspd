// Code generated by protoc-gen-go. DO NOT EDIT.
// source: lspd.proto

package lspd

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CanOpenChannelRequest struct {
	// / The identity pubkey of the Lightning node
	Pubkey               string   `protobuf:"bytes,1,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CanOpenChannelRequest) Reset()         { *m = CanOpenChannelRequest{} }
func (m *CanOpenChannelRequest) String() string { return proto.CompactTextString(m) }
func (*CanOpenChannelRequest) ProtoMessage()    {}
func (*CanOpenChannelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_lspd_ebfec18e50d1a22e, []int{0}
}
func (m *CanOpenChannelRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CanOpenChannelRequest.Unmarshal(m, b)
}
func (m *CanOpenChannelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CanOpenChannelRequest.Marshal(b, m, deterministic)
}
func (dst *CanOpenChannelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CanOpenChannelRequest.Merge(dst, src)
}
func (m *CanOpenChannelRequest) XXX_Size() int {
	return xxx_messageInfo_CanOpenChannelRequest.Size(m)
}
func (m *CanOpenChannelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CanOpenChannelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CanOpenChannelRequest proto.InternalMessageInfo

func (m *CanOpenChannelRequest) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

type LightningAddress struct {
	// / The identity pubkey of the Lightning node
	Pubkey string `protobuf:"bytes,1,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	// / The network location of the lightning node, e.g. `12.34.56.78:9012` or `localhost:10011`
	Host                 string   `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LightningAddress) Reset()         { *m = LightningAddress{} }
func (m *LightningAddress) String() string { return proto.CompactTextString(m) }
func (*LightningAddress) ProtoMessage()    {}
func (*LightningAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_lspd_ebfec18e50d1a22e, []int{1}
}
func (m *LightningAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LightningAddress.Unmarshal(m, b)
}
func (m *LightningAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LightningAddress.Marshal(b, m, deterministic)
}
func (dst *LightningAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LightningAddress.Merge(dst, src)
}
func (m *LightningAddress) XXX_Size() int {
	return xxx_messageInfo_LightningAddress.Size(m)
}
func (m *LightningAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_LightningAddress.DiscardUnknown(m)
}

var xxx_messageInfo_LightningAddress proto.InternalMessageInfo

func (m *LightningAddress) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

func (m *LightningAddress) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

type CanOpenChannelReply struct {
	// / Lightning address of the peer, in the format `<pubkey>@host`
	Addr                 *LightningAddress `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CanOpenChannelReply) Reset()         { *m = CanOpenChannelReply{} }
func (m *CanOpenChannelReply) String() string { return proto.CompactTextString(m) }
func (*CanOpenChannelReply) ProtoMessage()    {}
func (*CanOpenChannelReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_lspd_ebfec18e50d1a22e, []int{2}
}
func (m *CanOpenChannelReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CanOpenChannelReply.Unmarshal(m, b)
}
func (m *CanOpenChannelReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CanOpenChannelReply.Marshal(b, m, deterministic)
}
func (dst *CanOpenChannelReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CanOpenChannelReply.Merge(dst, src)
}
func (m *CanOpenChannelReply) XXX_Size() int {
	return xxx_messageInfo_CanOpenChannelReply.Size(m)
}
func (m *CanOpenChannelReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CanOpenChannelReply.DiscardUnknown(m)
}

var xxx_messageInfo_CanOpenChannelReply proto.InternalMessageInfo

func (m *CanOpenChannelReply) GetAddr() *LightningAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

type OpenChannelRequest struct {
	// / The identity pubkey of the Lightning node
	Pubkey               string   `protobuf:"bytes,1,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenChannelRequest) Reset()         { *m = OpenChannelRequest{} }
func (m *OpenChannelRequest) String() string { return proto.CompactTextString(m) }
func (*OpenChannelRequest) ProtoMessage()    {}
func (*OpenChannelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_lspd_ebfec18e50d1a22e, []int{3}
}
func (m *OpenChannelRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OpenChannelRequest.Unmarshal(m, b)
}
func (m *OpenChannelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OpenChannelRequest.Marshal(b, m, deterministic)
}
func (dst *OpenChannelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenChannelRequest.Merge(dst, src)
}
func (m *OpenChannelRequest) XXX_Size() int {
	return xxx_messageInfo_OpenChannelRequest.Size(m)
}
func (m *OpenChannelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenChannelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenChannelRequest proto.InternalMessageInfo

func (m *OpenChannelRequest) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

type OpenChannelReply struct {
	// / The transaction hash
	TxHash               string   `protobuf:"bytes,1,opt,name=tx_hash,proto3" json:"tx_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenChannelReply) Reset()         { *m = OpenChannelReply{} }
func (m *OpenChannelReply) String() string { return proto.CompactTextString(m) }
func (*OpenChannelReply) ProtoMessage()    {}
func (*OpenChannelReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_lspd_ebfec18e50d1a22e, []int{4}
}
func (m *OpenChannelReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OpenChannelReply.Unmarshal(m, b)
}
func (m *OpenChannelReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OpenChannelReply.Marshal(b, m, deterministic)
}
func (dst *OpenChannelReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenChannelReply.Merge(dst, src)
}
func (m *OpenChannelReply) XXX_Size() int {
	return xxx_messageInfo_OpenChannelReply.Size(m)
}
func (m *OpenChannelReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenChannelReply.DiscardUnknown(m)
}

var xxx_messageInfo_OpenChannelReply proto.InternalMessageInfo

func (m *OpenChannelReply) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func init() {
	proto.RegisterType((*CanOpenChannelRequest)(nil), "lspd.CanOpenChannelRequest")
	proto.RegisterType((*LightningAddress)(nil), "lspd.LightningAddress")
	proto.RegisterType((*CanOpenChannelReply)(nil), "lspd.CanOpenChannelReply")
	proto.RegisterType((*OpenChannelRequest)(nil), "lspd.OpenChannelRequest")
	proto.RegisterType((*OpenChannelReply)(nil), "lspd.OpenChannelReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ChannelOpenerClient is the client API for ChannelOpener service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChannelOpenerClient interface {
	CanOpenChannel(ctx context.Context, in *CanOpenChannelRequest, opts ...grpc.CallOption) (*CanOpenChannelReply, error)
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelReply, error)
}

type channelOpenerClient struct {
	cc *grpc.ClientConn
}

func NewChannelOpenerClient(cc *grpc.ClientConn) ChannelOpenerClient {
	return &channelOpenerClient{cc}
}

func (c *channelOpenerClient) CanOpenChannel(ctx context.Context, in *CanOpenChannelRequest, opts ...grpc.CallOption) (*CanOpenChannelReply, error) {
	out := new(CanOpenChannelReply)
	err := c.cc.Invoke(ctx, "/lspd.ChannelOpener/CanOpenChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelOpenerClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelReply, error) {
	out := new(OpenChannelReply)
	err := c.cc.Invoke(ctx, "/lspd.ChannelOpener/OpenChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChannelOpenerServer is the server API for ChannelOpener service.
type ChannelOpenerServer interface {
	CanOpenChannel(context.Context, *CanOpenChannelRequest) (*CanOpenChannelReply, error)
	OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelReply, error)
}

func RegisterChannelOpenerServer(s *grpc.Server, srv ChannelOpenerServer) {
	s.RegisterService(&_ChannelOpener_serviceDesc, srv)
}

func _ChannelOpener_CanOpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanOpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelOpenerServer).CanOpenChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.ChannelOpener/CanOpenChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelOpenerServer).CanOpenChannel(ctx, req.(*CanOpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelOpener_OpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelOpenerServer).OpenChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.ChannelOpener/OpenChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelOpenerServer).OpenChannel(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChannelOpener_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lspd.ChannelOpener",
	HandlerType: (*ChannelOpenerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CanOpenChannel",
			Handler:    _ChannelOpener_CanOpenChannel_Handler,
		},
		{
			MethodName: "OpenChannel",
			Handler:    _ChannelOpener_OpenChannel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lspd.proto",
}

func init() { proto.RegisterFile("lspd.proto", fileDescriptor_lspd_ebfec18e50d1a22e) }

var fileDescriptor_lspd_ebfec18e50d1a22e = []byte{
	// 261 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x91, 0xc1, 0x4a, 0xc3, 0x40,
	0x10, 0x86, 0x8d, 0x84, 0x4a, 0xa7, 0x28, 0x65, 0xd4, 0x10, 0xf5, 0x22, 0xeb, 0x45, 0xa4, 0x44,
	0xa8, 0x77, 0x21, 0xed, 0x4d, 0x0a, 0x96, 0xbc, 0x80, 0xa4, 0xdd, 0x21, 0x1b, 0x0c, 0x9b, 0x75,
	0x77, 0x2b, 0xe6, 0x65, 0x7c, 0x56, 0xc9, 0x26, 0x82, 0xc6, 0xf5, 0xd0, 0xdb, 0xcc, 0xce, 0xb7,
	0xff, 0xff, 0x33, 0x03, 0x50, 0x19, 0xc5, 0x13, 0xa5, 0x6b, 0x5b, 0x63, 0xd8, 0xd6, 0xec, 0x1e,
	0xce, 0x97, 0xb9, 0x7c, 0x56, 0x24, 0x97, 0x22, 0x97, 0x92, 0xaa, 0x8c, 0xde, 0x76, 0x64, 0x2c,
	0x46, 0x30, 0x52, 0xbb, 0xcd, 0x2b, 0x35, 0x71, 0x70, 0x1d, 0xdc, 0x8e, 0xb3, 0xbe, 0x63, 0x8f,
	0x30, 0x5d, 0x95, 0x85, 0xb0, 0xb2, 0x94, 0x45, 0xca, 0xb9, 0x26, 0x63, 0xfe, 0x63, 0x11, 0x21,
	0x14, 0xb5, 0xb1, 0xf1, 0xa1, 0x7b, 0x75, 0x35, 0x4b, 0xe1, 0x74, 0x68, 0xa8, 0xaa, 0x06, 0xef,
	0x20, 0xcc, 0x39, 0xd7, 0x4e, 0x60, 0x32, 0x8f, 0x12, 0x17, 0x74, 0x68, 0x94, 0x39, 0x86, 0xcd,
	0x00, 0xf7, 0x08, 0x3c, 0x83, 0xe9, 0x1f, 0xb7, 0x18, 0x8e, 0xec, 0xc7, 0x8b, 0xc8, 0x8d, 0xe8,
	0xe1, 0xef, 0x76, 0xfe, 0x19, 0xc0, 0x71, 0x8f, 0xb6, 0xbf, 0x48, 0xe3, 0x13, 0x9c, 0xfc, 0x0e,
	0x8c, 0x57, 0x5d, 0x3a, 0xef, 0xde, 0x2e, 0x2f, 0xfc, 0x43, 0x55, 0x35, 0xec, 0x00, 0x53, 0x98,
	0xfc, 0x14, 0x8a, 0x3b, 0xd6, 0xa3, 0x12, 0x79, 0x26, 0x4e, 0x62, 0x71, 0x03, 0x67, 0x65, 0x9d,
	0x14, 0x5a, 0x6d, 0x3b, 0xc4, 0x90, 0x7e, 0x2f, 0xb7, 0xb4, 0x18, 0xaf, 0x8c, 0xe2, 0xeb, 0xf6,
	0xb2, 0xeb, 0x60, 0x33, 0x72, 0x27, 0x7e, 0xf8, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x6b, 0x54, 0x55,
	0x60, 0xf0, 0x01, 0x00, 0x00,
}
