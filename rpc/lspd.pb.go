// Code generated by protoc-gen-go. DO NOT EDIT.
// source: lspd.proto

package lspd

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ChannelInformationRequest struct {
	// / The identity pubkey of the Lightning node
	Pubkey               string   `protobuf:"bytes,1,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelInformationRequest) Reset()         { *m = ChannelInformationRequest{} }
func (m *ChannelInformationRequest) String() string { return proto.CompactTextString(m) }
func (*ChannelInformationRequest) ProtoMessage()    {}
func (*ChannelInformationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_lspd_f6548acf9d60fb70, []int{0}
}
func (m *ChannelInformationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelInformationRequest.Unmarshal(m, b)
}
func (m *ChannelInformationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelInformationRequest.Marshal(b, m, deterministic)
}
func (dst *ChannelInformationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelInformationRequest.Merge(dst, src)
}
func (m *ChannelInformationRequest) XXX_Size() int {
	return xxx_messageInfo_ChannelInformationRequest.Size(m)
}
func (m *ChannelInformationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelInformationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelInformationRequest proto.InternalMessageInfo

func (m *ChannelInformationRequest) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

type ChannelInformationReply struct {
	// / The name of of lsp
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// / The identity pubkey of the Lightning node
	Pubkey string `protobuf:"bytes,2,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	// / The network location of the lightning node, e.g. `12.34.56.78:9012` or
	// / `localhost:10011`
	Host string `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
	// / The channel capacity in satoshis
	ChannelCapacity int64 `protobuf:"varint,4,opt,name=channel_capacity,proto3" json:"channel_capacity,omitempty"`
	// / The target number of blocks that the funding transaction should be
	// / confirmed by.
	TargetConf int32 `protobuf:"varint,5,opt,name=target_conf,proto3" json:"target_conf,omitempty"`
	// / The base fee charged regardless of the number of milli-satoshis sent.
	BaseFeeMsat int64 `protobuf:"varint,6,opt,name=base_fee_msat,proto3" json:"base_fee_msat,omitempty"`
	// / The effective fee rate in milli-satoshis. The precision of this value goes
	// / up to 6 decimal places, so 1e-6.
	FeeRate float64 `protobuf:"fixed64,7,opt,name=fee_rate,proto3" json:"fee_rate,omitempty"`
	// / The required timelock delta for HTLCs forwarded over the channel.
	TimeLockDelta uint32 `protobuf:"varint,8,opt,name=time_lock_delta,proto3" json:"time_lock_delta,omitempty"`
	// / The minimum value in millisatoshi we will require for incoming HTLCs on
	// / the channel.
	MinHtlcMsat          int64    `protobuf:"varint,9,opt,name=min_htlc_msat,proto3" json:"min_htlc_msat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelInformationReply) Reset()         { *m = ChannelInformationReply{} }
func (m *ChannelInformationReply) String() string { return proto.CompactTextString(m) }
func (*ChannelInformationReply) ProtoMessage()    {}
func (*ChannelInformationReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_lspd_f6548acf9d60fb70, []int{1}
}
func (m *ChannelInformationReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelInformationReply.Unmarshal(m, b)
}
func (m *ChannelInformationReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelInformationReply.Marshal(b, m, deterministic)
}
func (dst *ChannelInformationReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelInformationReply.Merge(dst, src)
}
func (m *ChannelInformationReply) XXX_Size() int {
	return xxx_messageInfo_ChannelInformationReply.Size(m)
}
func (m *ChannelInformationReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelInformationReply.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelInformationReply proto.InternalMessageInfo

func (m *ChannelInformationReply) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChannelInformationReply) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

func (m *ChannelInformationReply) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ChannelInformationReply) GetChannelCapacity() int64 {
	if m != nil {
		return m.ChannelCapacity
	}
	return 0
}

func (m *ChannelInformationReply) GetTargetConf() int32 {
	if m != nil {
		return m.TargetConf
	}
	return 0
}

func (m *ChannelInformationReply) GetBaseFeeMsat() int64 {
	if m != nil {
		return m.BaseFeeMsat
	}
	return 0
}

func (m *ChannelInformationReply) GetFeeRate() float64 {
	if m != nil {
		return m.FeeRate
	}
	return 0
}

func (m *ChannelInformationReply) GetTimeLockDelta() uint32 {
	if m != nil {
		return m.TimeLockDelta
	}
	return 0
}

func (m *ChannelInformationReply) GetMinHtlcMsat() int64 {
	if m != nil {
		return m.MinHtlcMsat
	}
	return 0
}

type OpenChannelRequest struct {
	// / The identity pubkey of the Lightning node
	Pubkey               string   `protobuf:"bytes,1,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenChannelRequest) Reset()         { *m = OpenChannelRequest{} }
func (m *OpenChannelRequest) String() string { return proto.CompactTextString(m) }
func (*OpenChannelRequest) ProtoMessage()    {}
func (*OpenChannelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_lspd_f6548acf9d60fb70, []int{2}
}
func (m *OpenChannelRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OpenChannelRequest.Unmarshal(m, b)
}
func (m *OpenChannelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OpenChannelRequest.Marshal(b, m, deterministic)
}
func (dst *OpenChannelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenChannelRequest.Merge(dst, src)
}
func (m *OpenChannelRequest) XXX_Size() int {
	return xxx_messageInfo_OpenChannelRequest.Size(m)
}
func (m *OpenChannelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenChannelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenChannelRequest proto.InternalMessageInfo

func (m *OpenChannelRequest) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

type OpenChannelReply struct {
	// / The transaction hash
	TxHash string `protobuf:"bytes,1,opt,name=tx_hash,proto3" json:"tx_hash,omitempty"`
	// / The output index
	OutputIndex          uint32   `protobuf:"varint,2,opt,name=output_index,proto3" json:"output_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenChannelReply) Reset()         { *m = OpenChannelReply{} }
func (m *OpenChannelReply) String() string { return proto.CompactTextString(m) }
func (*OpenChannelReply) ProtoMessage()    {}
func (*OpenChannelReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_lspd_f6548acf9d60fb70, []int{3}
}
func (m *OpenChannelReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OpenChannelReply.Unmarshal(m, b)
}
func (m *OpenChannelReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OpenChannelReply.Marshal(b, m, deterministic)
}
func (dst *OpenChannelReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenChannelReply.Merge(dst, src)
}
func (m *OpenChannelReply) XXX_Size() int {
	return xxx_messageInfo_OpenChannelReply.Size(m)
}
func (m *OpenChannelReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenChannelReply.DiscardUnknown(m)
}

var xxx_messageInfo_OpenChannelReply proto.InternalMessageInfo

func (m *OpenChannelReply) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *OpenChannelReply) GetOutputIndex() uint32 {
	if m != nil {
		return m.OutputIndex
	}
	return 0
}

func init() {
	proto.RegisterType((*ChannelInformationRequest)(nil), "lspd.ChannelInformationRequest")
	proto.RegisterType((*ChannelInformationReply)(nil), "lspd.ChannelInformationReply")
	proto.RegisterType((*OpenChannelRequest)(nil), "lspd.OpenChannelRequest")
	proto.RegisterType((*OpenChannelReply)(nil), "lspd.OpenChannelReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ChannelOpenerClient is the client API for ChannelOpener service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChannelOpenerClient interface {
	ChannelInformation(ctx context.Context, in *ChannelInformationRequest, opts ...grpc.CallOption) (*ChannelInformationReply, error)
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelReply, error)
}

type channelOpenerClient struct {
	cc *grpc.ClientConn
}

func NewChannelOpenerClient(cc *grpc.ClientConn) ChannelOpenerClient {
	return &channelOpenerClient{cc}
}

func (c *channelOpenerClient) ChannelInformation(ctx context.Context, in *ChannelInformationRequest, opts ...grpc.CallOption) (*ChannelInformationReply, error) {
	out := new(ChannelInformationReply)
	err := c.cc.Invoke(ctx, "/lspd.ChannelOpener/ChannelInformation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelOpenerClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelReply, error) {
	out := new(OpenChannelReply)
	err := c.cc.Invoke(ctx, "/lspd.ChannelOpener/OpenChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChannelOpenerServer is the server API for ChannelOpener service.
type ChannelOpenerServer interface {
	ChannelInformation(context.Context, *ChannelInformationRequest) (*ChannelInformationReply, error)
	OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelReply, error)
}

func RegisterChannelOpenerServer(s *grpc.Server, srv ChannelOpenerServer) {
	s.RegisterService(&_ChannelOpener_serviceDesc, srv)
}

func _ChannelOpener_ChannelInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelOpenerServer).ChannelInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.ChannelOpener/ChannelInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelOpenerServer).ChannelInformation(ctx, req.(*ChannelInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelOpener_OpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelOpenerServer).OpenChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.ChannelOpener/OpenChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelOpenerServer).OpenChannel(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChannelOpener_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lspd.ChannelOpener",
	HandlerType: (*ChannelOpenerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ChannelInformation",
			Handler:    _ChannelOpener_ChannelInformation_Handler,
		},
		{
			MethodName: "OpenChannel",
			Handler:    _ChannelOpener_OpenChannel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lspd.proto",
}

func init() { proto.RegisterFile("lspd.proto", fileDescriptor_lspd_f6548acf9d60fb70) }

var fileDescriptor_lspd_f6548acf9d60fb70 = []byte{
	// 381 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x52, 0xc1, 0x6e, 0xd4, 0x30,
	0x10, 0xc5, 0xed, 0x76, 0xdb, 0x9d, 0x12, 0x51, 0x8d, 0x50, 0x31, 0x2b, 0x21, 0xa2, 0xc0, 0x21,
	0x42, 0x68, 0x0f, 0xf4, 0x0b, 0x28, 0x27, 0x24, 0x24, 0x56, 0x39, 0x70, 0xb5, 0xbc, 0xce, 0x6c,
	0x13, 0x35, 0xb1, 0x4d, 0xec, 0xa0, 0xe6, 0x97, 0xf8, 0x03, 0xfe, 0x0e, 0x39, 0x09, 0x28, 0x61,
	0xbb, 0xe2, 0xf6, 0xe6, 0xe5, 0xcd, 0x9b, 0xe4, 0xe5, 0x01, 0x54, 0xce, 0xe6, 0x1b, 0xdb, 0x18,
	0x6f, 0x70, 0x11, 0x70, 0x72, 0x03, 0x2f, 0x3f, 0x15, 0x52, 0x6b, 0xaa, 0x3e, 0xeb, 0xbd, 0x69,
	0x6a, 0xe9, 0x4b, 0xa3, 0x33, 0xfa, 0xde, 0x92, 0xf3, 0x78, 0x0d, 0x4b, 0xdb, 0xee, 0xee, 0xa9,
	0xe3, 0x2c, 0x66, 0xe9, 0x2a, 0x1b, 0xa7, 0xe4, 0xd7, 0x09, 0xbc, 0x78, 0x6c, 0xcb, 0x56, 0x1d,
	0x22, 0x2c, 0xb4, 0xac, 0x69, 0xdc, 0xe8, 0xf1, 0xc4, 0xe7, 0x64, 0xea, 0x13, 0xb4, 0x85, 0x71,
	0x9e, 0x9f, 0x0e, 0xda, 0x80, 0xf1, 0x1d, 0x5c, 0xa9, 0xc1, 0x5a, 0x28, 0x69, 0xa5, 0x2a, 0x7d,
	0xc7, 0x17, 0x31, 0x4b, 0x4f, 0xb3, 0x03, 0x1e, 0x63, 0xb8, 0xf4, 0xb2, 0xb9, 0x23, 0x2f, 0x94,
	0xd1, 0x7b, 0x7e, 0x16, 0xb3, 0xf4, 0x2c, 0x9b, 0x52, 0xf8, 0x16, 0xa2, 0x9d, 0x74, 0x24, 0xf6,
	0x44, 0xa2, 0x76, 0xd2, 0xf3, 0x65, 0x6f, 0x35, 0x27, 0x71, 0x0d, 0x17, 0x01, 0x37, 0xd2, 0x13,
	0x3f, 0x8f, 0x59, 0xca, 0xb2, 0xbf, 0x33, 0xa6, 0xf0, 0xcc, 0x97, 0x35, 0x89, 0xca, 0xa8, 0x7b,
	0x91, 0x53, 0xe5, 0x25, 0xbf, 0x88, 0x59, 0x1a, 0x65, 0xff, 0xd2, 0xe1, 0x56, 0x5d, 0x6a, 0x51,
	0xf8, 0x4a, 0x0d, 0xb7, 0x56, 0xc3, 0xad, 0x19, 0x99, 0xbc, 0x07, 0xfc, 0x6a, 0x49, 0x8f, 0xf1,
	0xfd, 0x2f, 0xe9, 0x2d, 0x5c, 0xcd, 0xd4, 0x21, 0x61, 0x0e, 0xe7, 0xfe, 0x41, 0x14, 0xd2, 0x15,
	0xa3, 0xf8, 0xcf, 0x88, 0x09, 0x3c, 0x35, 0xad, 0xb7, 0xad, 0x17, 0xa5, 0xce, 0xe9, 0xa1, 0x4f,
	0x3b, 0xca, 0x66, 0xdc, 0x87, 0x9f, 0x0c, 0xa2, 0xd1, 0x2e, 0x38, 0x53, 0x83, 0xdf, 0x00, 0x0f,
	0x7f, 0x26, 0xbe, 0xde, 0xf4, 0x5d, 0x39, 0x5a, 0x8e, 0xf5, 0xab, 0xe3, 0x02, 0x5b, 0x75, 0xc9,
	0x13, 0xfc, 0x08, 0x97, 0x93, 0x77, 0x47, 0x3e, 0xe8, 0x0f, 0x3f, 0x7e, 0x7d, 0xfd, 0xc8, 0x93,
	0xde, 0xe2, 0xf6, 0x0d, 0x3c, 0x2f, 0xcd, 0xe6, 0xae, 0xb1, 0x6a, 0x90, 0x38, 0x6a, 0x7e, 0x94,
	0x8a, 0x6e, 0x57, 0x5f, 0x9c, 0xcd, 0xb7, 0xa1, 0xc6, 0x5b, 0xb6, 0x5b, 0xf6, 0x7d, 0xbe, 0xf9,
	0x1d, 0x00, 0x00, 0xff, 0xff, 0x47, 0xd9, 0x92, 0x62, 0xdd, 0x02, 0x00, 0x00,
}
